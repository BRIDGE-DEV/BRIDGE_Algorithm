# 게임판 덮기 문제 풀이

이 문제는 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 책의 6장 무식하게 풀기에 있는 보글 문제이다.

[해당 책 정리 이슈](https://github.com/fkdl0048/BookReview/issues/188)

BF알고리즘 문제 중 가장 오래걸린 문제이다..

## 문제

[게임판 덮기](https://algospot.com/judge/problem/read/BOARDCOVER)

H x W 크기의 게임판이 있다.

게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있는데 이 중 모든 흰 칸을 세 칸짜리 L자 모양의 블록으로 덮으려고 한다.

이때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안된다.

게임판이 주어질 때 이를 덮는 방법의 수를 계산하는 프로그램을 작성해라

- **시간 및 메모리 제한**
  - 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.
- **입력**
  - 첫 줄에는 테스트 케이스의 수가 주어진다.
  - 각 테스트 케이스의 첫 줄에는 두 개의 정수 H, W가 주어진다.
  - 다음 H 줄에 각 W 글자로 게임판의 모양이 주어진다.
  - `#`은 검은 칸, `.`은 흰 칸을 나타낸다.
  - 입력에 주어지는 게임판에 있는 흰 칸의 수는 50을 넘지 않는다.
- **출력**
  - 한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력한다.

*책에선 3의 배수가 아닌 경우 중복을 줄이는 수로 만들었는데 딱히 예제에는 표시되어 있지 않아서 구현하지 않았다.*

이 문제도 전 문제와 마찬가지로 **중복을 세는 문제**가 핵심이였다.

피크닉 문제에서 말했지만 보드판의 경우 왼쪽 위를 기준으로 중복을 세지 않도록 하였으며 백 트래킹의 구조도 동일하다.

```cs
if (_board.CanSetBlock(x, y, i))
{
    _board.SetBlock(x, y, i);
    count += GetCoverCount();
    _board.RemoveBlock(x, y, i);
}
```

블록이 L모양이기에 총 4개의 경우의 수를 더 돌리면 해당 칸에 배치 가능한지 여부를 판단하고 가능하다면 배치 후 기저 사례를 통해 검증한다.

만약 통과한다면 (여기선 모든 판을 다 채운 경우) 경우의 수를 늘려주고 아니라면 백트래킹으로 해당 칸을 지운다.

이게 문제의 전부다.

근데 이 문제의 상한을 단순 계산해보면 문제가 발생한다.

이 문제의 답의 최대는 한 블록당 4가지의 선택지와 최대 블록의 개수가 50개이기 때문에 가능한 답의 상한은 다음과 같다.

$$ \frac{50}{3} = 16 $$

$$ 4^{16} = 2^{32} $$

이것만 봐서는 도저히 시간 내에 모두 생성할 수 없을 것 같지만, 실제 입력을 손으로 풀어본다면 각 단계에서 선택할 수 있는 블록의 배치가 제한됨을 알 수 있다.

이는 전에 배치한 블록이 다음 블록에 영향을 주기 때문에 실제와 다르게 나온다.

*문제 예제의 10x10칸의 경우 실행이 가능하다.*

## 풀이

우선 cs파일이 커짐에 따라 클래스별로 파일을 분류해서 풀었다.

총 Program.cs, Board.cs, BoardCalculator.cs로 분류했다.

Program은 입력처리만 담당하였으며 Board는 Board객체 자체의 역할을 BoardCalculator는 문제에서 요구하는 답을 처리하기 위해 만들었다.

따라서 문제 풀이는 BoardCalculator만 봐도 이해가 될 것이다.

문제에서 가장 실수한 부분은 보글문제에선 쉽게 해결했지만 헷갈린 w, h의 2차원 배열에 대한 인덱싱 부분이였다.

실수로 이중 반복의 처리에서 i, j을 반대로 넣어줘 자꾸 혼동을 주었던 것이 시간을 많이 잡아먹었다.