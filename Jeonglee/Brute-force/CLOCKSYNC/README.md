# 시계 맞추기 풀이

이 문제는 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 책의 6장 무식하게 풀기에 있는 시계 맞추기 문제이다.

[해당 책 정리 이슈](https://github.com/fkdl0048/BookReview/issues/188)

[시계 맞추기](https://www.algospot.com/judge/problem/read/CLOCKSYNC)

![image](https://github.com/fkdl0048/Algorithm/assets/84510455/7b5640a0-433c-4de7-9c99-f08700f0bb23)

그림과 같이 4x4개의 격자 형태로 배치된 열여섯 개의 시계가 있다.

이 시계는 모두 12시, 3시, 6시 혹은 9시를 가리키는데, 이 시계들을 모두 12시를 가리키도록 하고 싶다.

시계의 시간을 조작하는 유일한 방법은 열개의 스위치를 조작하는 것으로, 각 스위치들을은 모두 적게는 세 개에서 많게는 다섯 개의 시계에 연결되어 있다.

한 스위치를 누를 때마다, 해당 스위치와 연결된 시계들의 시간은 3시간씩 앞으로 움직인다.

번호와 연결된 시계에 따라 최소 몇번의 스위치 조작을 통해 모든 시계를 12시로 돌릴 수 있는지 작성하라

- 시간 및 메모리 제한
  - 10초안에 실행되어야 하며 64MB 이하의 메모리를 사용해야 한다.
- 입력
  - 첫 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄에 16개의 정수로 주어지며, 각 정수는 0번부터 15번까지 각 시계가 가리키고 있는 시간을 12, 3, 6, 9중 하나로 표현한다.
- 출력
  - 각 테스트 케이스당 정수 하나를 한 줄에 출력한다.
  - 이 정수는 시계들을 모두 12시로 돌려놓기 위해 스위치를 눌러야 할 최소 횟수이며, 만약 불가능하다면 -1을 출력해야 한다.

이 문제는 생각도 못한 문제라 책의 설명을 보지 않고 풀어볼려고 했을 때 너무 복잡해졌다.

문제를 보자마자 Foranger의 기믹이 생각났는데 그런 경우의 수를 구할 때 사용하면 좋을 문제인 것 같다.

## 문제 변형

이 문제는 있는 그대로 풀면 꽤나 복잡하다.

그러나 문제의 특성을 이용해 적절히 단순화하면 완전 탐색으로 해결할 수 있다.

이 문제의 중요한 점은 예제 입출력 설명이 유도하는 방향과는 달리 스위치를 누르는 순서는 전혀 중요하지 않다는 것이다.

두 스위치를 누르는 순서를 바꾼다고 해서 그 결과가 바뀌지 않기 때문이다.

따라서 우리가 계산해야 할 것은 스위츠를 **몇 번이나 누를 것**이냐 뿐이다.

문제를 바꾼다고 해서 완전 탐색을 바로 적용할 수는 없고 사용하려면 누르는 횟수의 조합을 하나하나 열거할 수 있어야 하는데, 그 조합의 수는 무한하다.

하지만 시계는 12시간이 지나면 제자리로 돌아온다는 점을 이용하면 유한하게 바꿀 수 있다.

어떤 시계든 4번 누른 경우에 누르지 않은 것과 같기 때문에 어떤 스위치던 3번 이상 누를 일이 없어진다.

따라서 스위치를 누르는 경우의 수는 0~3으로 나오고 이를 계산하면 4^10 = 1,048,576개가 된다.

```cs
private int Solve(int switchNumber)
{
    if (switchNumber == SwitchNumber)
    {
        return AreAligned() ? 0 : Inf;
    }

    int ret = Inf;

    for (int count = 0; count < 4; count++)
    {
        ret = Math.Min(ret, count + Solve(switchNumber + 1));

        Push(switchNumber);
    }

    return ret;
}
```

4번을 누르면 다시 돌아간다는 아이디어를 통해 ret을 반환하는 것이 코드에 잘 보여진다.

기저사례는 모든 시계가 12여야 한다는 명확한 조건이 있기 때문에 다음과 같이 정리된다.

```cs
if (switchNumber == SwitchNumber)
{
    return AreAligned() ? 0 : Inf;
}

private bool AreAligned()
{
    for (int i = 0; i < ClockNumber; i++)
    {
        if (_clocks[i] != 12)
        {
            return false;
        }
    }

    return true;
}
```